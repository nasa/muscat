%% Class: True_SC_Navigation
% Tracks the position and velocity of the SC

classdef True_SC_Navigation < handle

    %% Properties
    properties

        %% [ ] Properties: Initialized Variables

        position % [km] : Current position of SC in inertial frame I
        velocity % [km/sec] : Current velocity of SC in inertial frame I
        position_relative_target % [km] : Current position of SC relative to SB-center J2000 inertial frame
        velocity_relative_target % [km/sec] : Current velocity of SC relative to SB-center J2000 inertial frame
        name_relative_target % [string] : Name of the target, relative to which position and velocity are specified

        spice_filename % [string] : SC's SPICE FileName
        spice_name % [string] : SC's SPICE Name

        mode_true_SC_navigation_dynamics_selector % [string] Different navigation dynamics modes
        % - 'SPICE' : Use pre-computed SPICE trajectory
        % - 'Absolute Dynamics'
        % - 'Relative Dynamics'

        %% [ ] Properties: Variables Computed Internally

        index_relative_target % [integer] : Index of the target, relative to which position and velocity are specified

        flag_visible_Sun % [Boolean] Check if Sun is visible
        flag_visible_Earth % [Boolean] Check if Earth is visible

        flag_SC_crashed % [Boolean] Check if SC has crashed into anything!
        position_array % [km] Position array wrt Sun-centered J2000, corresponding to time array in mission.true_time.time_position_array        

        control_force % [N] : Control force vector generated by thrusters (e.g. MT, CT) that passes through Center of Mass of SC
        disturbance_force % [N] : Disturbance force vector generated by SRP that passes through Center of Mass of SC

        ode_options % : Options for Matlab%s ODE function odeset( RelTol',1e-14,'AbsTol',1e-14)

        %% [ ] Properties: Storage Variables

        store

    end

    %% Methods
    methods

        %% [ ] Methods: Constructor
        % Construct an instance of this class

        function obj = True_SC_Navigation(init_data, mission)

            if strcmp(mission.frame,'Absolute') || isfield(init_data, 'position')
                obj.position = init_data.position; % [km]
                obj.velocity = init_data.velocity; % [km/sec]

                if isfield(init_data, 'name_relative_target')
                    obj.name_relative_target = init_data.name_relative_target;
                else
                    obj.name_relative_target = mission.true_target{1}.name;
                end

                for i_target = 1:1:mission.num_target
                    if strcmp(mission.true_target{i_target}.name, obj.name_relative_target)
                        obj.index_relative_target = i_target;
                        position_target = mission.true_target{i_target}.position;
                        velocity_target = mission.true_target{i_target}.velocity;
                    end
                end

                obj.position_relative_target = obj.position - position_target; % [km]
                obj.velocity_relative_target = obj.velocity - velocity_target; % [km/sec]


            elseif strcmp(mission.frame,'Relative') || isfield(init_data, 'position_relative_target')
                obj.position_relative_target = sc_body_init_data.position_relative_target; % [km]
                obj.velocity_relative_target = sc_body_init_data.velocity_relative_target; % [km/sec]
                obj.name_relative_target = init_data.name_relative_target; % [string]

                for i_target = 1:1:mission.num_target
                    if strcmp(mission.true_target{i_target}.name, obj.name_relative_target)
                        obj.index_relative_target = i_target;
                        position_target = mission.true_target{i_target}.position;
                        velocity_target = mission.true_target{i_target}.velocity;
                    end
                end

                obj.position = position_target + obj.position_relative_target; % [km]
                obj.velocity = velocity_target + obj.velocity_relative_target; % [km/sec]

            else
                error('Navigation initialization incorrect!')
            end

            obj.control_force = [0 0 0]; % [N]
            obj.disturbance_force = [0 0 0]; % [N]
            obj.flag_SC_crashed = 0;


            % Select Dynamics Mode
            obj.mode_true_SC_navigation_dynamics_selector = init_data.mode_true_SC_navigation_dynamics_selector; % [string]

            if strcmp( obj.mode_true_SC_navigation_dynamics_selector, 'SPICE' )
                % Use SPICE trajectory
                obj.spice_filename = init_data.spice_filename;
                obj.spice_name = init_data.spice_name;
                cspice_furnsh(obj.spice_filename)
            end

            obj.ode_options = odeset('RelTol',1e-14,'AbsTol',1e-14);

            % Update flag visible
            obj = func_update_visible_Sun_Earth(obj, mission);
            
            % Initialize Variables to store: position and velocity of SC
            obj.store = [];

            obj.store.position = zeros(mission.storage.num_storage_steps, length(obj.position));
            obj.store.velocity = zeros(mission.storage.num_storage_steps, length(obj.velocity));
            obj.store.position_relative_target = zeros(mission.storage.num_storage_steps, length(obj.position_relative_target));
            obj.store.velocity_relative_target = zeros(mission.storage.num_storage_steps, length(obj.velocity_relative_target));
            obj.store.flag_visible_Sun = zeros(mission.storage.num_storage_steps, length(obj.flag_visible_Sun));
            obj.store.flag_visible_Earth = zeros(mission.storage.num_storage_steps, length(obj.flag_visible_Earth));

            obj = func_update_true_SC_navigation_store(obj, mission);

        end

        %% [ ] Methods: Store
        % Update the store variable

        function obj = func_update_true_SC_navigation_store(obj, mission)

            if mission.storage.flag_store_this_time_step == 1
                obj.store.position(mission.storage.k_storage,:) = obj.position; % [km]
                obj.store.velocity(mission.storage.k_storage,:) = obj.velocity; % [km/sec]
                obj.store.position_relative_target(mission.storage.k_storage,:) = obj.position_relative_target; % [km]
                obj.store.velocity_relative_target(mission.storage.k_storage,:) = obj.velocity_relative_target; % [km/sec]
                obj.store.flag_visible_Sun(mission.storage.k_storage,:) = obj.flag_visible_Sun; % [Boolean]
                obj.store.flag_visible_Earth(mission.storage.k_storage,:) = obj.flag_visible_Earth; % [Boolean]
            end

        end


        %% [ ] Methods: Main
        % Select method to update position and velocity

        function obj = func_main_true_SC_navigation(obj, mission, i_SC)
            
            switch obj.mode_true_SC_navigation_dynamics_selector

                case 'SPICE'
                    % Use SPICE trajectory
                    obj = func_update_SC_navigation_position_velocity_SPICE(obj, mission);

                case 'Absolute Dynamics'
                    % Use Absolute Dynamics
                    obj = func_update_SC_navigation_position_velocity_Absolute_Dynamics(obj, mission, i_SC);

                otherwise
                    error('Navigation mode not defined!')
            end

            % Update flag visible
            obj = func_update_visible_Sun_Earth(obj, mission);

            % Update SC crash
            obj = func_update_flag_SC_crashed(obj, mission, i_SC);

            % Store
            obj = func_update_true_SC_navigation_store(obj, mission);

            obj.control_force = [0 0 0]; % [N]
            obj.disturbance_force = [0 0 0]; % [N]

        end

        %% [ ] Methods: Update Position Velocity SPICE
        % Update position and velocity using SPICE

        function obj = func_update_SC_navigation_position_velocity_SPICE(obj, mission)

            SC_pos_vel = cspice_spkezr(obj.spice_name,mission.true_time.date,'J2000','NONE','SUN');

            obj.position = SC_pos_vel(1:3)'; % [km]
            obj.velocity = SC_pos_vel(4:6)'; % [km/sec]

            position_target = mission.true_target{obj.index_relative_target}.position;
            velocity_target = mission.true_target{obj.index_relative_target}.velocity;

            obj.position_relative_target = obj.position - position_target; % [km]
            obj.velocity_relative_target = obj.velocity - velocity_target; % [km/sec]

            SC_pos_vel_array = (cspice_spkezr(obj.spice_name, mission.true_time.prev_date + mission.true_time.time_position_array' ,'J2000','NONE','SUN'))';
            obj.position_array = SC_pos_vel_array(:,1:3);

        end


        %% [ ] Methods: Update Position Velocity Absolute Dynamics
        % Update position and velocity using Absolute dynamics

        function obj = func_update_SC_navigation_position_velocity_Absolute_Dynamics(obj, mission, i_SC)

            this_time_array = mission.true_time.time_position_array;
            
            obj = obj.func_update_disturbance_force(mission, i_SC);

            SC_pos_vel_current = [obj.position'; obj.velocity']; % [km, km/sec] in (6,1) format
            [T,X]=ode113(@(t,X) func_ode_orbit_inertial_absolute_dynamics(t, X, mission, i_SC), this_time_array, SC_pos_vel_current, obj.ode_options);

            new_SC_pos_vel_current = X(end,:);

            obj.position = new_SC_pos_vel_current(1:3); % [km]
            obj.velocity = new_SC_pos_vel_current(4:6); % [km/sec]

            position_target = mission.true_target{obj.index_relative_target}.position;
            velocity_target = mission.true_target{obj.index_relative_target}.velocity;

            obj.position_relative_target = obj.position - position_target; % [km]
            obj.velocity_relative_target = obj.velocity - velocity_target; % [km/sec]

            obj.position_array = X(:,1:3); % [km]

        end


        function obj = func_update_disturbance_force(obj,mission, i_SC)
            % Sum up all disturbance forces
            obj.disturbance_force = mission.true_SC{i_SC}.true_SRP.disturbance_force_SRP';
        end
      



        %% [ ] Methods: Update Visible Sun Earth
        % Update flag_visible_Sun and flag_visible_Earth

        function obj = func_update_visible_Sun_Earth(obj, mission)

            % Use lins math: https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html

            for i_vis = 1:1:2

                flag_visible = 1;

                if i_vis == 1
                    % Sun
                    x1 = mission.true_solar_system.SS_body{mission.true_solar_system.index_Sun}.position; % [km]
                elseif i_vis == 2
                    % Earth
                    x1 = mission.true_solar_system.SS_body{mission.true_solar_system.index_Earth}.position; % [km]
                else
                    error('Shouldnt reach here')
                end

                % SC Position
                x2 = obj.position; % [km]

                % Check all Targets
                for i_target = 1:1:mission.num_target

                    x0 = mission.true_target{i_target}.position; % [km]

                    d = norm(cross(x0 - x1, x0 - x2))/norm(x2 - x1);
                    if d >= mission.true_target{i_target}.radius % [km]
                        % No chance of eclipse
                    else
                        % Check t
                        t = - dot(x1 - x0, x2 - x1 )/ (norm(x2  - x1))^2;
                        if (t >= 0) && (t <= 1)
                            flag_visible = 0;
                        else
                            % Body is outside the line of sight
                        end
                    end
                end

                % Check all SS Bodies
                for i_SS_body = 1:1:mission.true_solar_system.num_SS_body

                    if (i_vis == 1) && (i_SS_body == mission.true_solar_system.index_Sun)
                        % Skip this!

                    elseif (i_vis == 2) && (i_SS_body == mission.true_solar_system.index_Earth)
                        % Skip this!

                    else

                        x0 = mission.true_solar_system.SS_body{i_SS_body}.position; % [km]

                        d = norm(cross(x0 - x1, x0 - x2))/norm(x2 - x1);
                        if d >= mission.true_solar_system.SS_body{i_SS_body}.radius % [km]
                            % No chance of eclipse
                        else
                            % Check t
                            t = - dot(x1 - x0, x2 - x1 )/ (norm(x2  - x1))^2;
                            if (t >= 0) && (t <= 1)
                                flag_visible = 0;
                            else
                                % Body is outside the line of sight
                            end
                        end

                    end
                end


                if i_vis == 1
                    % Sun
                    obj.flag_visible_Sun = flag_visible;
                elseif i_vis == 2
                    % Earth
                    obj.flag_visible_Earth = flag_visible;
                else
                    error('Shouldnt reach here')
                end


            end

        end


        %% [ ] Methods: Check SC Crashed
        % Update flag_SC_crashed

        function obj = func_update_flag_SC_crashed(obj, mission, i_SC)

            for t = 1:1:length(mission.true_time.time_position_array)

                % SC position
                x1 = obj.position_array(t,:);

                % Check all Targets
                for i_target = 1:1:mission.num_target

                    x0 = mission.true_target{i_target}.position_array(t,:); % [km]

                    if norm(x0 - x1) <= mission.true_target{i_target}.radius % [km]
                        obj.flag_SC_crashed = 1;
                        disp('-----------------------------------------------')
                        disp(['SC ',num2str(i_SC),' crashed into ',mission.true_target{i_target}.name])
                        disp('-----------------------------------------------')
                        mission.storage.flag_stop_sim = 1;
                        break;
                    end

                end

            end

        end

    end
end

