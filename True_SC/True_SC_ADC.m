%% Class: True_SC_ADC
% Tracks the attitude and angular velocity of the SC

classdef True_SC_ADC < handle


    %% Properties
    properties

        %% [ ] Properties: Initialized Variables

        attitude % [quanternion] : Orientation of inertial frame I with respect to the body frame B

        angular_velocity % [rad/sec] : Angular velocity of inertial frame I with respect to the body frame B

        mode_true_SC_attitude_dynamics_selector % [string] Different attitude dynamics modes
        % - 'Rigid' : Use Rigid Body Dynamics



        %% [ ] Properties: Variables Computed Internally

        rotation_matrix % : Rotation matrix that converts vector in body frame B to vector in inertial frame I
        dot_angular_velocity % [rad/sec^2] : Time derivative of angular_velocity (needed by RWA) 
                % RWA - Reaction Wheels | MT momentum Thrusters?
        control_torque % [Nm] : Control torque about Center of Mass of SC, usually generated by MT thrusters and RWA
        disturbance_torque % [Nm] : Disturbance torque about Center of Mass of SC
        total_torque % [Nm] - Sum of the two above

        total_wheel_momentum % [kgâ‹…m^2/s] : Total momentum of all reaction wheels

        ode_options % : Options for Matlab%s ODE function odeset( RelTol',1e-14,'AbsTol',1e-14)
        
        plot_handle % : plot handle for attitude visualization

        %% [ ] Properties: Storage Variables

        store

    end

    %% Methods
    methods

        %% [ ] Methods: Constructor
        % Construct an instance of this class

        function obj = True_SC_ADC(init_data, mission)

            obj.attitude = func_quaternion_properize(init_data.attitude); % [quaternion]
            obj.angular_velocity = init_data.angular_velocity; % [rad/sec]

            % Compute Rotation Matrix
            obj = func_update_true_SC_ADC_rotation_matrix(obj);

            obj.dot_angular_velocity = [0 0 0];
            obj.control_torque = [0 0 0];
            obj.disturbance_torque = [0 0 0];
            obj.total_wheel_momentum = [0 0 0]; % Initialize as 3x1 vector
            obj.total_torque = [0 0 0];

            obj.ode_options = odeset('RelTol',1e-14,'AbsTol',1e-14);

            obj.mode_true_SC_attitude_dynamics_selector = init_data.mode_true_SC_attitude_dynamics_selector;

            % Initialize Variables to store: attitude and angular velocity of SC
            obj.store = [];

            obj.store.attitude = zeros(mission.storage.num_storage_steps_attitude, length(obj.attitude));
            obj.store.angular_velocity = zeros(mission.storage.num_storage_steps_attitude, length(obj.angular_velocity));

            obj.store.control_torque = zeros(mission.storage.num_storage_steps_attitude, length(obj.control_torque));
            obj.store.disturbance_torque = zeros(mission.storage.num_storage_steps_attitude, length(obj.disturbance_torque));
            obj.store.total_torque = zeros(mission.storage.num_storage_steps_attitude, length(obj.total_torque));


            obj = func_update_true_SC_adc_store(obj, mission);
        end

        %% [ ] Methods: Store
        % Update the store variable

        function obj = func_update_true_SC_adc_store(obj, mission)
            if mission.storage.flag_store_this_time_step_attitude == 1
                obj.store.attitude(mission.storage.k_storage_attitude,:) = obj.attitude; % [sec]
                obj.store.angular_velocity(mission.storage.k_storage_attitude,:) = obj.angular_velocity; % [sec]

                obj.store.control_torque(mission.storage.k_storage_attitude,:) = obj.control_torque; % [sec]
                obj.store.disturbance_torque(mission.storage.k_storage_attitude,:) = obj.disturbance_torque; % [sec]
                obj.store.total_torque(mission.storage.k_storage_attitude,:) = obj.total_torque; % [sec]
            end
        end


        %% [ ] Methods: Main
        % Update SC's Attitude and Angular Velocity

        function obj = func_main_true_SC_attitude(obj, mission, i_SC)

            switch obj.mode_true_SC_attitude_dynamics_selector

                case 'Rigid'

                    % Update disturbance torque is done
                    % in the SRP and GG classes

                    % Update total wheel momentum
                    obj = func_update_total_wheel_momentum(obj, mission, i_SC);

                    % Update attitude and angular velocity
                    obj = func_true_SC_attitude_dynamics_rigid(obj, mission, i_SC);

                otherwise
                    error('Havent written yet!')

            end
            
            % Sum torques for storage
            obj.total_torque = obj.control_torque + obj.disturbance_torque;

            % Compute Rotation Matrix
            obj = func_update_true_SC_ADC_rotation_matrix(obj);

            % Store
            obj = func_update_true_SC_adc_store(obj, mission);

            % Reset variables
            obj.control_torque =  [0 0 0];     % [Nm]

            % Reset every main time step
            if (mission.true_time.k_attitude == mission.true_time.num_time_steps_attitude)
                obj.disturbance_torque = [0 0 0]; % Reset torque
            end
        end


        %% [ ] Methods: Update Rotation Matrix
        % Update SC's Rotation Matrix

        function obj = func_update_true_SC_ADC_rotation_matrix(obj)

            % Compute Rotation Matrix
            SC_True_e_current = obj.attitude(1:3)/norm(obj.attitude(1:3));
            SC_True_Phi_current = 2*acos(obj.attitude(4)); % [rad]
            obj.rotation_matrix = func_create_rotation_matrix(SC_True_e_current, SC_True_Phi_current);

        end

        %% [ ] Methods: Rigid Attitude Dynamics
        % Update SC's Attitude and Angular Velocity

        function obj = func_true_SC_attitude_dynamics_rigid(obj, mission, i_SC)

            SC_Quaternion_Omega_current = [obj.attitude'; obj.angular_velocity'];

            this_time_array = [0 mission.true_time.time_step_attitude];

            [T,X]=ode45(@(t,X) func_ode_attitude_dynamics(t, X, mission, i_SC), this_time_array, SC_Quaternion_Omega_current, obj.ode_options);

            new_SC_Quaternion_Omega_current = X(end,:);

            obj.attitude = func_quaternion_properize(new_SC_Quaternion_Omega_current(1:4)); % [quaternion]
            obj.angular_velocity = new_SC_Quaternion_Omega_current(5:7); % [rad/sec]

            %retrieve cache
            X_dot = func_ode_attitude_dynamics(this_time_array(end), new_SC_Quaternion_Omega_current', mission, i_SC);
            obj.dot_angular_velocity = X_dot(5:7)';

        end

        
        %% [ ] Methods: Update Reaction Wheel Momentum
        
        function obj = func_update_total_wheel_momentum(obj, mission, i_SC)
            % Initialize total wheel momentum as a 3x1 vector
            obj.total_wheel_momentum = zeros(3, 1);
            
            % Loop through all reaction wheels and add their individual momentum vectors
            for i = 1:mission.true_SC{i_SC}.true_SC_body.num_hardware_exists.num_reaction_wheel
                % Each wheel's total_momentum is already a vector in the body frame
                if isfield(mission.true_SC{i_SC}.true_SC_reaction_wheel{i}, 'total_momentum') && ...
                   ~isempty(mission.true_SC{i_SC}.true_SC_reaction_wheel{i}.total_momentum)
                    obj.total_wheel_momentum = obj.total_wheel_momentum + mission.true_SC{i_SC}.true_SC_reaction_wheel{i}.total_momentum;
                end
            end
        end
        
        

    end
end

