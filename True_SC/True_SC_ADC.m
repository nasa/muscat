%% Class: True_SC_ADC
% Tracks the attitude and angular velocity of the SC

classdef True_SC_ADC < handle


    %% Properties
    properties

        %% [ ] Properties: Initialized Variables

        attitude % [quanternion] : Orientation of inertial frame I with respect to the body frame B

        angular_velocity % [rad/sec] : Angular velocity of inertial frame I with respect to the body frame B

        mode_true_SC_attitude_dynamics_selector % [string] Different attitude dynamics modes
        % - 'Rigid' : Use Rigid Body Dynamics



        %% [ ] Properties: Variables Computed Internally
        rotation_matrix % : Rotation matrix that converts vector in body frame B to vector in inertial frame I
        dot_angular_velocity % [rad/sec^2] : Time derivative of angular_velocity (needed by RWA) 
                % RWA - Reaction Wheels | MT momentum Thrusters?
        control_torque % [Nm] : Control torque about Center of Mass of SC, usually generated by MT thrusters and RWA
        disturbance_torque % [Nm] : Disturbance torque about Center of Mass of SC
        total_torque % [Nm] - Sum of the two above

        total_wheel_momentum % [kgâ‹…m^2/s] : Total momentum of all reaction wheels

        ode_options % : Options for Matlab%s ODE function odeset( RelTol',1e-14,'AbsTol',1e-14)
        
        plot_handle % : plot handle for attitude visualization

        %% [ ] Properties: Storage Variables

        store

    end

    %% Methods
    methods

        %% [ ] Methods: Constructor
        % Construct an instance of this class

        function obj = True_SC_ADC(init_data, mission)

            obj.attitude = func_quaternion_properize(init_data.attitude); % [quaternion]
            obj.angular_velocity = init_data.angular_velocity; % [rad/sec]

            % Compute Rotation Matrix
            obj = func_update_true_SC_ADC_rotation_matrix(obj);

            obj.dot_angular_velocity = zeros(3,1);
            obj.control_torque = zeros(3,1);
            obj.disturbance_torque = zeros(3,1);
            obj.total_wheel_momentum = zeros(3,1); % Initialize as 3x1 vector
            obj.total_torque = zeros(3,1);

            obj.ode_options = odeset('RelTol',1e-14,'AbsTol',1e-14);

            obj.mode_true_SC_attitude_dynamics_selector = init_data.mode_true_SC_attitude_dynamics_selector;

            % Initialize Variables to store: attitude and angular velocity of SC
            obj.store = [];

            obj.store.attitude = zeros(mission.storage.num_storage_steps_attitude, length(obj.attitude));
            obj.store.angular_velocity = zeros(mission.storage.num_storage_steps_attitude, length(obj.angular_velocity));

            obj.store.control_torque = zeros(mission.storage.num_storage_steps_attitude, length(obj.control_torque));
            obj.store.disturbance_torque = zeros(mission.storage.num_storage_steps_attitude, length(obj.disturbance_torque));
            obj.store.total_torque = zeros(mission.storage.num_storage_steps_attitude, length(obj.total_torque));


            obj = func_update_true_SC_adc_store(obj, mission);
        end

        %% [ ] Methods: Store
        % Update the store variable

        function obj = func_update_true_SC_adc_store(obj, mission)
            if mission.storage.flag_store_this_time_step_attitude == 1
                obj.store.attitude(mission.storage.k_storage_attitude,:) = obj.attitude; % [sec]
                obj.store.angular_velocity(mission.storage.k_storage_attitude,:) = obj.angular_velocity; % [sec]

                obj.store.control_torque(mission.storage.k_storage_attitude,:) = obj.control_torque; % [sec]
                obj.store.disturbance_torque(mission.storage.k_storage_attitude,:) = obj.disturbance_torque; % [sec]
                obj.store.total_torque(mission.storage.k_storage_attitude,:) = obj.total_torque; % [sec]
            end
        end


        %% [ ] Methods: Main
        % Update SC's Attitude and Angular Velocity

        function obj = func_main_true_SC_attitude(obj, mission, i_SC)

            switch obj.mode_true_SC_attitude_dynamics_selector

                case 'Rigid'

                    % Update disturbance torque is done
                    % in the SRP and GG classes

                    % Update total wheel momentum
                    obj = obj.func_update_total_wheel_momentum(mission, i_SC);

                    % Update attitude and angular velocity
                    obj = obj.func_true_SC_attitude_dynamics_rigid(mission, i_SC);

                otherwise
                    error('Havent written yet!')

            end
            
            % Sum torques for storage
            obj.total_torque = obj.control_torque + obj.disturbance_torque;

            % Compute Rotation Matrix
            obj = func_update_true_SC_ADC_rotation_matrix(obj);

            % Store
            obj = func_update_true_SC_adc_store(obj, mission);

            % Reset variables
            obj.control_torque =  zeros(3,1);     % [Nm]

            % Reset every main time step
            if (mission.true_time.k_attitude == mission.true_time.num_time_steps_attitude)
                obj.disturbance_torque = zeros(3,1); % Reset torque
            end
        end


        %% [ ] Methods: Update Rotation Matrix
        % Update SC's Rotation Matrix

        function obj = func_update_true_SC_ADC_rotation_matrix(obj)

            % Compute Rotation Matrix
            SC_True_e_current = obj.attitude(1:3)/norm(obj.attitude(1:3));
            SC_True_Phi_current = 2*acos(obj.attitude(4)); % [rad]
            obj.rotation_matrix = func_create_rotation_matrix(SC_True_e_current, SC_True_Phi_current);

        end

        %% [ ] Methods: Rigid Attitude Dynamics
        % Update SC's Attitude and Angular Velocity

        function obj = func_true_SC_attitude_dynamics_rigid(obj, mission, i_SC)

            SC_Quaternion_Omega_current = [obj.attitude'; obj.angular_velocity'];

            this_time_array = [0 mission.true_time.time_step_attitude];

            [T,X]=ode45(@(t,X) func_ode_attitude_dynamics(t, X, mission, i_SC), this_time_array, SC_Quaternion_Omega_current, obj.ode_options);

            new_SC_Quaternion_Omega_current = X(end,:);

            obj.attitude = func_quaternion_properize(new_SC_Quaternion_Omega_current(1:4)); % [quaternion]
            obj.angular_velocity = new_SC_Quaternion_Omega_current(5:7); % [rad/sec]

            %retrieve cache
            X_dot = func_ode_attitude_dynamics(this_time_array(end), new_SC_Quaternion_Omega_current', mission, i_SC);
            obj.dot_angular_velocity = X_dot(5:7)';

        end

        
        %% [ ] Methods
        function obj = func_update_total_wheel_momentum(obj, mission, i_SC)
            % Initialize total wheel momentum as a 3x1 vector
            obj.total_wheel_momentum = zeros(3, 1);
            
            % Loop through all reaction wheels and add their individual momentum vectors
            for i = 1:mission.true_SC{i_SC}.true_SC_body.num_hardware_exists.num_reaction_wheel
                % Each wheel's total_momentum is already a vector in the body frame
                if isfield(mission.true_SC{i_SC}.true_SC_reaction_wheel{i}, 'total_momentum') && ...
                   ~isempty(mission.true_SC{i_SC}.true_SC_reaction_wheel{i}.total_momentum)
                    obj.total_wheel_momentum = obj.total_wheel_momentum + mission.true_SC{i_SC}.true_SC_reaction_wheel{i}.total_momentum;
                end
            end
        end
        
        
        function obj = func_visualize_attitude(obj,storage_data, true_SC_body, true_SC_solar_panel, software_SC_control_attitude,true_SC_micro_thruster_actuator, true_SC_chemical_thruster_actuator,mission_true_time)

            mArrow3([0 0 0]',[1 0 0]', 'facealpha', 0.1, 'color', 'r', 'stemWidth', 0.01);
            hold on
            mArrow3([0 0 0]',[0 1 0]', 'facealpha', 0.1, 'color', 'g', 'stemWidth', 0.01);
            mArrow3([0 0 0]',[0 0 1]', 'facealpha', 0.1, 'color', 'b', 'stemWidth', 0.01);


            mArrow3([0 0 0]',obj.rotation_matrix*[0.5 0 0]', 'facealpha', 1, 'color', 'r', 'stemWidth', 0.005);
            mArrow3([0 0 0]',obj.rotation_matrix*[0 0.5 0]', 'facealpha', 1, 'color', 'g', 'stemWidth', 0.005);
            mArrow3([0 0 0]',obj.rotation_matrix*[0 0 0.5]', 'facealpha', 1, 'color', 'b', 'stemWidth', 0.005);


            % SC body shape
            SC_Shape_Model = [];
            SC_Shape_Model.Vertices = (obj.rotation_matrix * true_SC_body.shape_model.Vertices')';
            SC_Shape_Model.Faces = true_SC_body.shape_model.Faces;
            patch(SC_Shape_Model, 'FaceColor',0.7*[1 1 1], 'EdgeColor', 'none')


            % SP shape
            for i=1:true_SC_solar_panel.num_solar_panels
                SP_Shape_Model = [];
                SP_Shape_Model.Vertices = (obj.rotation_matrix * true_SC_solar_panel.solar_panel_data(i).shape_model.Vertices')';
                SP_Shape_Model.Faces = true_SC_solar_panel.solar_panel_data(i).shape_model.Faces;
                patch(SP_Shape_Model, 'FaceColor','blue', 'EdgeColor', 'none')
            end


            % Microthruster
            if true_SC_body.flag_hardware_exists.adc_micro_thruster == 1
                for i=1:true_SC_micro_thruster_actuator.num_micro_thruster
                    loc = obj.rotation_matrix * true_SC_micro_thruster_actuator.MT_data(i).location;
                    dir = obj.rotation_matrix * true_SC_micro_thruster_actuator.MT_data(i).orientation;
                    scale = true_SC_micro_thruster_actuator.MT_data(i).commanded_thrust*0.1/true_SC_micro_thruster_actuator.MT_data(i).maximum_thrust;
                    quiver3(loc(1),loc(2),loc(3) , dir(1),dir(2),dir(3),"LineWidth",3,"DisplayName",['MT ',num2str(i)],"AutoScaleFactor",scale)
                end
            end


            % Chemical Thruster
            if true_SC_body.flag_hardware_exists.navigation_chemical_thruster == 1
                for i=1:true_SC_chemical_thruster_actuator.num_chemical_thruster
                    loc = obj.rotation_matrix * true_SC_chemical_thruster_actuator.chemical_thruster_data(i).location;
                    dir = obj.rotation_matrix * true_SC_chemical_thruster_actuator.chemical_thruster_data(i).orientation;
                    scale = true_SC_chemical_thruster_actuator.chemical_thruster_data(i).commanded_thrust*0.15/true_SC_micro_thruster_actuator.MT_data(i).maximum_thrust;
                    quiver3(loc(1),loc(2),loc(3) , dir(1),dir(2),dir(3),"LineWidth",10,"DisplayName",['CT ',num2str(i)],"AutoScaleFactor",scale)
                end
            end


            view([-25,30])
            axis equal
            xlim([-1 1])
            ylim([-1 1])
            zlim([-1 1])
            if software_SC_control_attitude.actuator_to_use == 1
                info_actuator ="Attitude Actuator in use : MT";
            elseif software_SC_control_attitude.actuator_to_use == 2
                info_actuator ="Attitude Actuator in use : RWA";
            elseif software_SC_control_attitude.actuator_to_use == 3
                info_actuator ="Attitude Actuator in use : both (DESAT)";
            else
                % nothing
            end
            if software_SC_control_attitude.desired_SC_attitude_mode == 1
                info_pointing = "Pointing for : SB";
            elseif software_SC_control_attitude.desired_SC_attitude_mode == 2
                info_pointing = "Pointing for : SUN";
            elseif software_SC_control_attitude.desired_SC_attitude_mode == 3
                info_pointing = "Pointing for: DELTA V";
            elseif software_SC_control_attitude.desired_SC_attitude_mode == 4
                info_pointing = "Pointing for: DTE";
            elseif software_SC_control_attitude.desired_SC_attitude_mode == 5
                info_pointing = "Pointing for: INTERSAT comm";
            else
                % nothing
            end
            if sum([true_SC_chemical_thruster_actuator.chemical_thruster_data.command_actuation])>0
                info_thrust = "Thruster firing !";
            else
                info_thrust = "Thruster OFF";
            end
            title ([['Mission Simulation, Time = ',num2str(round(mission_true_time.time)),' sec'],info_actuator,info_pointing,info_thrust])


            light
            camlight('headlight')
            grid on

            xlabel('X_{SUN}')
            ylabel('Y_{SUN}')
            zlabel('Z_{SUN}')


            set(gca, 'fontsize',storage_data.plot_parameters.standard_font_size,'FontName','Times New Roman')
            hold off

            drawnow limitrate


        end


    end
end

