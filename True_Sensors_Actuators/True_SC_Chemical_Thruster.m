%% Class: True_SC_Chemical_Thruster
% Individual SC's chemical thruster

classdef True_SC_Chemical_Thruster < handle

    % True_SC_Chemical_Thruster class represents a single chemical-thruster
    % with various properties and methods for simulation and analysis.

    %% Properties
    properties

        %% [ ] Properties: Initialized Variables

        instantaneous_power_consumption  %[Watts] : Instantaneous power consumed by unit (if it is switched on)
        
        thruster_warm_up_power_consumed  %[Watts] : Power consumed during warm-up time

        command_actuation_power_consumed %[Watts] : Power consumed during actuation
        
        name                             % Name of the thruster

        thruster_noise                   %[N] : Added to every dimension of commanded_thrust
        
        isp                              %[s] : Specific impulse of the thruster

        command_wait_time                %[sec] : Seconds between commands

        orientation                      %[Unit vector] : Normal vector of thrust in body frame B
        location                         %[m] : Location of actuator, in body frame B

        maximum_thrust                   %[N]
        minimum_thrust                   %[N] : This need not be 0

        %% [ ] Properties: Variables Computed Internally

        instantaneous_power_consumed     %[Watts] : Alias for power tracking system

        health                           % Health of the thruster (0 : Not working - 1 : Working)
        temperature                      %[Celsius] Temperature of the thruster
        
        instantaneous_data_generated_per_sample     %[kb] : Data generated during the current time step, in kilo bits

        control_force_CT                 %[N] : Control force vector generated by the unit that passes through Center of Mass of SC
        control_torque_CT                %[Nm] : Control torque about Center of Mass of SC, generated by the unit

        mode_true_chemical_thruster_selector% Mode (Truth/Simple)
        flag_executive % [Bool] do we need to fire this time step (set by sw orbit control)
        flag_warming_up % [Bool] is the thruster in warm-up mode

        thruster_warm_up_time            %[sec] : How much warm-up time is needed?
        accumulated_warm_up_time         %[sec] : How long has the thruster been warming up
        command_time                     %[sec] : Time when latest Command was actuated
        
        warm_up_start_time               %[sec] : Time when warm-up started
        ready_state_start_time           %[sec] : Time when thruster entered ready state
        pending_fire                     %[Boolean] : Flag to indicate a pending fire command between cycles
        pending_thrust                   %[N] : Remembered thrust value for a pending fire command

        command_actuation                %[Boolean] : 1 = Command actuation during this time step (after actuator has warmed up)
        command_executed                 %[Boolean] : 1 = Command executed during this time step
        
        thruster_state                   %[String] : Current state of the thruster: 'idle', 'warming_up', 'ready', 'firing'

        
        force_inertial                   %[N] : Vector force in inertial frame applied by this thruster
        
        commanded_thrust                 %[N] : Comes from the SC's orbit control software
        
        true_commanded_thrust            %[N] : Actual thrust with noise applied, unknown to SC software

        % New properties for fuel consumption
        fuel_consumed_per_firing         %[kg] : Amount of fuel consumed in current firing
        total_fuel_consumed              %[kg] : Total fuel consumed by this thruster

        %% [ ] Properties: Storage Variables

        store                            % Structure to store historical data
    end

    %% Methods
    methods
        
        %% [ ] Methods: Constructor
        % Construct an instance of this class

        function obj = True_SC_Chemical_Thruster(init_data, mission, i_SC, i_MT)
            if isfield(init_data, 'name')
                obj.name = init_data.name;
            else
                obj.name = ['Chemical Thruster ', num2str(i_MT)];
            end
            obj.health = true;
            obj.temperature = 20;
            obj.instantaneous_power_consumption = init_data.instantaneous_power_consumption; % Watts
            obj.instantaneous_power_consumed = init_data.instantaneous_power_consumption; % Watts
            
            % Initialize specific power consumption settings
            if isfield(init_data, 'thruster_warm_up_power_consumed')
                obj.thruster_warm_up_power_consumed = init_data.thruster_warm_up_power_consumed; % Watts
            else
                obj.thruster_warm_up_power_consumed = obj.instantaneous_power_consumption; % Default to regular power
            end
            
            if isfield(init_data, 'command_actuation_power_consumed')
                obj.command_actuation_power_consumed = init_data.command_actuation_power_consumed; % Watts
            else
                obj.command_actuation_power_consumed = 3 * obj.instantaneous_power_consumption; % Default to 3x regular power
            end
            
            obj.instantaneous_data_generated_per_sample = init_data.instantaneous_data_generated_per_sample; % Kb
            obj.thruster_noise = init_data.chemical_thruster_noise; % Noise level
            obj.command_wait_time = init_data.command_wait_time; % Seconds between commands
            obj.location = init_data.location; % Meters (body frame)
            obj.orientation = init_data.orientation; % Unit vector (body frame)

            obj.isp = init_data.chemical_thruster_ISP; % sec
            obj.force_inertial = zeros(1,3);

            obj.minimum_thrust = init_data.minimum_thrust;
            obj.maximum_thrust = init_data.maximum_thrust;
            
            % Ensure thrust variables are properly initialized as scalars
            obj.commanded_thrust = 0; % Initialize as scalar 0, not empty array
            obj.true_commanded_thrust = 0; % Initialize as scalar 0, not empty array
            obj.control_force_CT = zeros(1,3); % Ensure it's a 1x3 array
            obj.control_torque_CT = zeros(1,3); % Ensure it's a 1x3 array

            % Initialize warm-up related properties
            obj.thruster_warm_up_time = 30; % Default warm-up time (30 seconds)
            obj.accumulated_warm_up_time = 0;
            obj.warm_up_start_time = 0;
            obj.ready_state_start_time = 0;
            obj.flag_warming_up = false;
            obj.thruster_state = 'idle';
            
            % Initialize command properties
            obj.command_actuation = false;
            obj.command_executed = false;
            obj.command_time = 0;
            obj.flag_executive = false;
            obj.pending_fire = false;
            obj.pending_thrust = 0;
                        
            % Initialize fuel consumption properties
            obj.fuel_consumed_per_firing = 0;
            obj.total_fuel_consumed = 0;

            % Initialize Storage Variables
            obj.store = [];
            obj.store.commanded_thrust = zeros(mission.storage.num_storage_steps,1);
            obj.store.true_commanded_thrust = zeros(mission.storage.num_storage_steps,1);
            obj.store.force_inertial = zeros(mission.storage.num_storage_steps,3); % Changed from 1 to 3 columns
            obj.store.fuel_consumed_per_firing = zeros(mission.storage.num_storage_steps,1);
            obj.store.total_fuel_consumed = zeros(mission.storage.num_storage_steps,1);
            obj.store.thruster_state = cell(mission.storage.num_storage_steps,1);
            obj.store.warm_up_progress = zeros(mission.storage.num_storage_steps,1);
            obj.store.pending_fire = zeros(mission.storage.num_storage_steps,1);
            obj.store.pending_thrust = zeros(mission.storage.num_storage_steps,1);
            obj.store.control_torque_CT = zeros(mission.storage.num_storage_steps,3); % Add storage

            % Update storage
            func_update_true_chemical_thruster_store(obj, mission);
                        
            % Update SC Power Class
            func_initialize_list_HW_energy_consumed(mission.true_SC{i_SC}.true_SC_power, obj, mission);

            % Update SC Data Handling Class
            func_initialize_list_HW_data_generated(mission.true_SC{i_SC}.true_SC_data_handling, obj, mission);
        end

        %% [ ] Methods: Store
        % Update the store variable

        function obj = func_update_true_chemical_thruster_store(obj, mission)
            % Append new thrust data to the storage arrays
            
            % Ensure all values are valid before storing (defend against empty arrays)
            if isempty(obj.commanded_thrust)
                obj.commanded_thrust = 0;
            end
            
            if isempty(obj.true_commanded_thrust)
                obj.true_commanded_thrust = 0;
            end
            
            % Store values with safety checks
            obj.store.commanded_thrust(mission.storage.k_storage,:) = obj.commanded_thrust;
            obj.store.true_commanded_thrust(mission.storage.k_storage,:) = obj.true_commanded_thrust;
            obj.store.force_inertial(mission.storage.k_storage,:) = obj.force_inertial;
            obj.store.fuel_consumed_per_firing(mission.storage.k_storage,:) = obj.fuel_consumed_per_firing;
            obj.store.total_fuel_consumed(mission.storage.k_storage,:) = obj.total_fuel_consumed;
            obj.store.thruster_state{mission.storage.k_storage} = obj.thruster_state;
            
            % Store pending fire information
            obj.store.pending_fire(mission.storage.k_storage) = obj.pending_fire;
            obj.store.pending_thrust(mission.storage.k_storage) = obj.pending_thrust;
            
            % Store control torque
            obj.store.control_torque_CT(mission.storage.k_storage,:) = obj.control_torque_CT;
            
            % Calculate warm-up progress as a percentage
            if obj.thruster_warm_up_time > 0
                obj.store.warm_up_progress(mission.storage.k_storage) = min(100, (obj.accumulated_warm_up_time / obj.thruster_warm_up_time) * 100);
            else
                obj.store.warm_up_progress(mission.storage.k_storage) = 100; % No warm-up needed
            end
        end

        %% [ ] Methods: Start Warm-Up

        function obj = func_start_warm_up(obj, mission)
            % Start the thruster warm-up process
            if ~obj.flag_warming_up && strcmp(obj.thruster_state, 'idle') && obj.health
                obj.flag_warming_up = true;
                obj.thruster_state = 'warming_up';
                obj.warm_up_start_time = mission.true_time.time;
                obj.accumulated_warm_up_time = 0;
            end
        end

        %% [ ] Methods: Check Warm-Up Status

        function is_ready = func_is_thruster_ready(obj)
            % Check if the thruster is ready to fire
            is_ready = strcmp(obj.thruster_state, 'ready') || strcmp(obj.thruster_state, 'firing');
        end
        
        %% [ ] Methods: Validate Thruster Properties

        function obj = func_validate_thruster_properties(obj)
            % Safety function to ensure all properties are properly initialized
            
            % Check and fix scalar properties
            if isempty(obj.commanded_thrust)
                obj.commanded_thrust = 0;
            end
            
            if isempty(obj.true_commanded_thrust)
                obj.true_commanded_thrust = 0;
            end
            
            if isempty(obj.instantaneous_power_consumption)
                obj.instantaneous_power_consumption = 0;
            end
            
            if isempty(obj.instantaneous_power_consumed)
                obj.instantaneous_power_consumed = 0;
            end
            
            % Check and fix vector properties
            if isempty(obj.force_inertial) || ~isequal(size(obj.force_inertial), [1,3])
                obj.force_inertial = zeros(1,3);
            end
            
            if isempty(obj.control_torque_CT) || ~isequal(size(obj.control_torque_CT), [1,3])
                obj.control_torque_CT = zeros(1,3);
            end
            
            if isempty(obj.control_force_CT) || ~isequal(size(obj.control_force_CT), [1,3])
                obj.control_force_CT = zeros(1,3);
            end
            
            % Check other critical properties
            if isempty(obj.thruster_state)
                obj.thruster_state = 'idle';
            end
            
            if isempty(obj.ready_state_start_time)
                obj.ready_state_start_time = 0;
            end
            
            if isempty(obj.pending_fire)
                obj.pending_fire = false;
            end
            
            if isempty(obj.pending_thrust)
                obj.pending_thrust = 0;
            end
            
            if isempty(obj.instantaneous_data_generated_per_sample)
                obj.instantaneous_data_generated_per_sample = 0;
            end
        end
        
        %% [ ] Methods: Main 

        function func_main_true_chemical_thruster(obj, mission, i_SC, ~)
            % Main function for True_SC_Chemical_Thruster
            % Controls thrust application, power consumption, and data generation.

            % Validate properties to ensure everything is properly initialized
            obj = func_validate_thruster_properties(obj);
            
            % Reset fuel consumed this firing (but NOT command_executed - that needs
            % to persist for one cycle so orbit control can see it)
            obj.fuel_consumed_per_firing = 0;
            
            % Initialize power consumption to idle value
            obj.instantaneous_power_consumption = 0;
            obj.instantaneous_power_consumed = 0;

            % Save a local copy of command_executed for this cycle's processing
            was_executed_last_cycle = obj.command_executed;
            
            % Check health status
            if obj.health == 0
                obj.thruster_state = 'idle';
                obj.flag_warming_up = false;
                obj.command_executed = false;
                return;
            end
            
            % State machine for thruster operation
            switch obj.thruster_state
                case 'idle'
                    % Check if we need to start warming up
                    if obj.flag_warming_up
                        disp(['Thruster transitioning from idle to warming_up at time ', num2str(mission.true_time.time), ' sec']);
                        obj.thruster_state = 'warming_up';
                        obj.accumulated_warm_up_time = 0;
                    end
                    
                    % Minimal idle power consumption (fixed 0.1W in idle state)
                    obj.instantaneous_power_consumption = 0.1;
                    
                case 'warming_up'
                    % Update accumulated warm-up time
                    obj.accumulated_warm_up_time = obj.accumulated_warm_up_time + mission.true_time.time_step;
                    
                    % Check if warm-up is complete
                    if obj.accumulated_warm_up_time >= obj.thruster_warm_up_time
                        disp(['Thruster completed warm-up and entering ready state at time ', num2str(mission.true_time.time), ' sec']);
                        obj.thruster_state = 'ready';
                        obj.ready_state_start_time = mission.true_time.time; % Set the start time of ready state
                    end
                    
                    % Set warm-up power consumption
                    obj.instantaneous_power_consumption = obj.thruster_warm_up_power_consumed;
                    
                case 'ready'
                    % Thruster is ready to fire
                    % Maintain warm-up power until firing or timeout
                    obj.instantaneous_power_consumption = obj.thruster_warm_up_power_consumed;
                    
                    % Check for command actuation
                    if obj.flag_executive && obj.commanded_thrust > 0
                        % Save the command for the next cycle
                        obj.pending_fire = true;
                        obj.pending_thrust = obj.commanded_thrust;
                        
                        disp(['Thruster transitioning from ready to firing at time ', num2str(mission.true_time.time), ' sec']);
                        disp(['  Commanded thrust: ', num2str(obj.commanded_thrust), ' N']);
                        obj.thruster_state = 'firing';
                    end
                    
                    % Check for timeout (5 minutes idle in ready state)
                    % Use the ready_state_start_time as reference to measure timeout period
                    if (mission.true_time.time - obj.ready_state_start_time) > 300
                        disp(['Thruster timing out from ready state after ', num2str(mission.true_time.time - obj.ready_state_start_time), ' seconds']);
                        obj.thruster_state = 'idle';
                        obj.flag_warming_up = false;
                    end
                    
                case 'firing'
                    % Process thruster firing - use either current command or pending command from previous cycle
                    if (obj.flag_executive && obj.commanded_thrust > 0) || obj.pending_fire
                        try
                            % Use either active command or saved pending command
                            if obj.flag_executive && obj.commanded_thrust > 0
                                thrust_to_use = obj.commanded_thrust;
                            else
                                thrust_to_use = obj.pending_thrust;
                                disp(['Using pending thrust from previous cycle: ', num2str(thrust_to_use), ' N']);
                            end
                            
                            % Update thrust with noise
                            obj.true_commanded_thrust = thrust_to_use + obj.thruster_noise * (2*rand() - 1);

                            % Ensure thrust remains within bounds
                            obj.true_commanded_thrust = max(min(obj.true_commanded_thrust, obj.maximum_thrust), obj.minimum_thrust);

                            % Get current attitude matrix to transform from body to inertial frame
                            R = quaternionToRotationMatrix(mission.true_SC{i_SC}.true_SC_adc.attitude);

                            % Calculate force vector in body frame first
                            force_body = obj.true_commanded_thrust * obj.orientation;

                            % Transform to inertial frame
                            obj.force_inertial = R * force_body'; % Netwons
                            
                            % Log the thruster firing 
                            disp(['THRUSTER FIRING with thrust of ', num2str(obj.true_commanded_thrust), ' N at time ', num2str(mission.true_time.time), ' sec']);
                            
                            % Make sure that the control orbit verifies if
                            % the deltaV has been performed correctly
                            mission.true_SC{i_SC}.software_SC_control_orbit.flag_executive = 1;

                            % Add thrust on the SC (in inertial frame)
                            mission.true_SC{i_SC}.true_SC_navigation.control_force = mission.true_SC{i_SC}.true_SC_navigation.control_force + obj.force_inertial';

                            % Compute the disturbance torque
                            r = obj.location - mission.true_SC{i_SC}.true_SC_body.location_COM;
                            obj.control_torque_CT = cross(r, force_body)';
                            
                            % Apply torque to attitude system
                            mission.true_SC{i_SC}.true_SC_adc.disturbance_torque = mission.true_SC{i_SC}.true_SC_adc.disturbance_torque + obj.control_torque_CT;

                            obj.control_torque_CT = obj.control_torque_CT';

                            % Update power consumption (warm-up + actuation)
                            obj.instantaneous_power_consumption = obj.thruster_warm_up_power_consumed + obj.command_actuation_power_consumed;
                            
                            % Set command execution flag - this will persist until next cycle
                            obj.command_executed = true;
                            
                            % Calculate DeltaV applied and directly update orbit control
                            dt = mission.true_time.time_step;
                            sc_mass = mission.true_SC{i_SC}.true_SC_body.total_mass;
                            
                            % Calculate DeltaV applied (normalized direction * magnitude)
                            DeltaV_applied = (norm(obj.force_inertial) * dt / sc_mass) * (obj.force_inertial / norm(obj.force_inertial));
                            
                            % Update orbit control's total executed DeltaV directly
                            mission.true_SC{i_SC}.software_SC_control_orbit.total_DeltaV_executed = mission.true_SC{i_SC}.software_SC_control_orbit.total_DeltaV_executed + DeltaV_applied;
                            
                            % Log the actuation
                            disp(['Applied DeltaV: [', num2str(DeltaV_applied(1)), ', ', num2str(DeltaV_applied(2)), ', ', num2str(DeltaV_applied(3)), '] m/s']);
                            disp(['Total DeltaV now: [', num2str(mission.true_SC{i_SC}.software_SC_control_orbit.total_DeltaV_executed(1)), ', ', ...
                                  num2str(mission.true_SC{i_SC}.software_SC_control_orbit.total_DeltaV_executed(2)), ', ', ...
                                  num2str(mission.true_SC{i_SC}.software_SC_control_orbit.total_DeltaV_executed(3)), '] m/s']);
                            
                            % Calculate and display the remaining DeltaV to be applied
                            remaining_DeltaV = mission.true_SC{i_SC}.software_SC_control_orbit.desired_control_DeltaV - mission.true_SC{i_SC}.software_SC_control_orbit.total_DeltaV_executed;
                            disp(['Remaining DeltaV: ', num2str(norm(remaining_DeltaV)), ' m/s']);
                            
                            % Data generatio
                            if isempty(obj.instantaneous_data_volume) 
                                obj.instantaneous_data_volume = obj.instantaneous_data_generated;
                            end
                            
                            % Calculate fuel consumption
                            dt = mission.true_time.time_step;
                            g0 = 9.80665; % m/s^2
                            obj.fuel_consumed_per_firing = (obj.true_commanded_thrust * dt) / (obj.isp * g0);
                            obj.total_fuel_consumed = obj.total_fuel_consumed + obj.fuel_consumed_per_firing;
                            
                            % Consume fuel from the tank if fuel tank exists
                            if isfield(mission.true_SC{i_SC}, 'true_SC_fuel_tank') && ...
                               mission.true_SC{i_SC}.true_SC_body.num_hardware_exists.num_fuel_tank > 0
                                
                                % Find the assigned fuel tank for this thruster (assuming the first one for now)
                                i_tank = 1; % In a more complex implementation, each thruster might have a specific tank assigned
                                
                                % Consume fuel from the tank
                                mission.true_SC{i_SC}.true_SC_fuel_tank{i_tank}.func_consume_fuel(obj.fuel_consumed_per_firing);
                            end
                            
                            % Clear pending fire flag after successful firing
                            obj.pending_fire = false;
                            obj.pending_thrust = 0;
                            
                        catch exception
                            % Log error but continue execution
                            %                             warning('Error during thruster firing: %s', exception.message);
                            warning('Error during thruster firing');
                            obj.thruster_state = 'ready';
                            obj.command_executed = false;
                            obj.pending_fire = false;
                            obj.pending_thrust = 0;
                        end
                    else
                        % No command to fire, go back to ready state
                        if strcmp(obj.thruster_state, 'firing')
                            disp(['Thruster returning to ready state from firing at time ', num2str(mission.true_time.time), ' sec']);
                        end
                        obj.thruster_state = 'ready';
                        % We don't reset command_executed here as it needs to persist for one cycle
                    end
            end
            
            % Always update power consumed for power tracking
            obj.instantaneous_power_consumed = obj.instantaneous_power_consumption;
            
            % Update Power Consumed
            func_update_instantaneous_power_consumed(mission.true_SC{i_SC}.true_SC_power, obj, mission);

            % Update Data Generated
            func_update_instantaneous_data_generated(mission.true_SC{i_SC}.true_SC_data_handling, obj, mission);
            
            % Update storage
            obj.func_update_true_chemical_thruster_store(mission);

            % Reset executive flag and thrust command after processing
            obj.flag_executive = false;
            obj.commanded_thrust = 0;
            obj.control_torque_CT = zeros(1,3); 
            
            % Reset command_executed flag ONLY if it was set in the previous cycle
            % (not the current one)
            if was_executed_last_cycle
                obj.command_executed = false;
            end
            
            obj.true_commanded_thrust = 0;
        end
    end
end
