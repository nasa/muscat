%% Class: True_SC_Micro_Thruster
% Individual SC's micro thruster

classdef True_SC_Micro_Thruster < handle
    
    % True_SC_Micro_Thruster class represents a single micro-thruster
    % with various properties and methods for simulation and analysis.
   
    %% Properties
    properties

        %% [ ] Properties: Initialized Variables

        instantaneous_power_consumption  %[Watts] : Instantaneous power consumed by unit (if it is switched on)

        instantaneous_data_generated_per_sample     %[kb] : Data generated during the current time step, in kilo bits

        mode_true_SC_micro_thruster_selector % Mode (Truth/Simple)

        thruster_noise                   %[N] : Added to every dimension of commanded_thrust

        isp                              %[s] : Specific impulse of the thruster

        maximum_thrust                   %[N]

        minimum_thrust                   %[N] 

        command_wait_time                %[sec] : Seconds betzeen commands

        orientation                      %[Unit vector] : Normal vector of thrust in body frame B

        location                         %[m] : Location of actuator, in body frame B


        %% [ ] Properties: Variables Computed Internally

        instantaneous_data_volume        % [kb]
        
        instantaneous_power_consumed     %[Watts] 
        thruster_warm_up_power_consumed  %[Watts] : Power consumed during warm-up time
        command_actuation_power_consumed %[Watts] : Power consumed during actuation
        name                             % Name of the thruster
        health                           % Health of the thruster (0 : Not working - 1 : Working)
        temperature                      %[Celcius] Temerature of the thruster       

        control_force_MT                 %[N] : Control force vector generated by the unit that passes through Center of Mass of SC
        control_torque_MT                %[Nm] : Control torque about Center of Mass of SC, generated by the unit

        thruster_warm_up_time            %[sec] : How much warm-up time is needed?
        accumulated_warm_up_time         %[sec] 
        command_time                     %[sec] : Time when latest Command was actuated
               
        command_actuation                %[Boolean] :  Command actuation during this time step (after actuator has warmed up)
        command_executed                 %[Boolean] :  Command executed during this time step

        commanded_thrust                 %[N] : Comes from the SC's software
        
        true_commanded_thrust            %[N] : Add thruster noise to commanded_thrust. This is the actual thrust of this thruster, which the SC software doesn t know.  

        % Fuel consumption properties
        
        fuel_consumed_per_firing         %[kg] : Amount of fuel consumed in current firing
        total_fuel_consumed              %[kg] : Total fuel consumed by this thruster

        %% [ ] Properties: Storage Variables

        store
    end
    
    %% Methods
    methods
        
        %% [ ] Methods: Constructor
        % Construct an instance of this class

        function obj = True_SC_Micro_Thruster(init_data, mission, i_SC, i_MT)
            if isfield(init_data, 'name')
                obj.name = init_data.name;
            else
                obj.name = ['Micro Thruster ', num2str(i_MT)];
            end
            obj.health = true;
            obj.temperature = 20;
            obj.instantaneous_power_consumption = init_data.instantaneous_power_consumption; % Watts
            obj.instantaneous_power_consumed = init_data.instantaneous_power_consumption; % Watts
            obj.instantaneous_data_generated_per_sample = init_data.instantaneous_data_generated_per_sample; % Kb
            obj.mode_true_SC_micro_thruster_selector = init_data.mode_true_SC_micro_thruster_selector; % Mode (Truth/Simple)
            obj.command_wait_time = init_data.command_wait_time; % Seconds between commands
            obj.location = init_data.location; % Meters (body frame)

            obj.orientation = init_data.orientation; % Unit vector (body frame)
            obj.orientation = obj.orientation / norm(obj.orientation); % Normalize

            obj.thruster_noise = init_data.thruster_noise; % Noise level [N]
            obj.minimum_thrust = init_data.minimum_thrust;
            obj.maximum_thrust = init_data.maximum_thrust; % [N]
            
            % Set default values for warm-up parameters
            obj.thruster_warm_up_time = 0; % Default no warm-up
            obj.accumulated_warm_up_time = 0;
            obj.thruster_warm_up_power_consumed = 0;
            obj.command_actuation_power_consumed = obj.instantaneous_power_consumption; % Default to regular consumption
            obj.instantaneous_data_volume = obj.instantaneous_data_generated_per_sample; % [kb]

            % Initialize fuel consumption properties
            obj.isp = init_data.micro_thruster_ISP; % Get ISP from init data
            obj.fuel_consumed_per_firing = 0;
            obj.total_fuel_consumed = 0;

            % Reset all variables
            obj = func_reset_state(obj);
            
            % Initialize Storage Variables
            obj.store = [];
            obj.store.true_commanded_thrust = zeros(mission.storage.num_storage_steps_attitude,1);
            obj.store.control_torque_MT = zeros(mission.storage.num_storage_steps_attitude,3); % Initialize as empty numeric array
            obj.store.fuel_consumed_per_firing = zeros(mission.storage.num_storage_steps_attitude,1);
            obj.store.total_fuel_consumed = zeros(mission.storage.num_storage_steps_attitude,1);

            % Update storage
            func_update_true_SC_micro_thruster_store(obj, mission);
            
            % Update SC Power Class
            func_initialize_list_HW_energy_consumed(mission.true_SC{i_SC}.true_SC_power, obj, mission);

            % Update SC Data Handling Class
            func_initialize_list_HW_data_generated(mission.true_SC{i_SC}.true_SC_data_handling, obj, mission);
          
        end

        %% [ ] Methods: Store
        % Update the store variable

        function obj = func_update_true_SC_micro_thruster_store(obj, mission)
            % Append new thrust data to the storage arrays            
            obj.store.true_commanded_thrust(mission.storage.k_storage_attitude,:) = obj.true_commanded_thrust;
            obj.store.control_torque_MT(mission.storage.k_storage_attitude,:) = obj.control_torque_MT;
            obj.store.fuel_consumed_per_firing(mission.storage.k_storage_attitude,:) = obj.fuel_consumed_per_firing;
            obj.store.total_fuel_consumed(mission.storage.k_storage_attitude,:) = obj.total_fuel_consumed;
        end
        
        %% [ ] Methods: Reset         

        function obj = func_reset_state(obj)
            % Reset temporary state variables after each time step
            % This ensures clean state for the next time step
            
            % Reset actuation flags
            obj.command_actuation = false;
            obj.command_executed = false;
            
            % Reset thruster state for next time step
            obj.commanded_thrust = 0;
            obj.true_commanded_thrust = 0;
            obj.control_torque_MT = [0, 0, 0];
            
            % Reset fuel consumption for this firing
            % Note: total_fuel_consumed is kept as it's cumulative
            obj.fuel_consumed_per_firing = 0;
        end

        %% [ ] Methods: Main

        function func_main_true_SC_micro_thruster(obj, mission, i_SC, ~)
            % Main function for True_SC_Micro_Thruster
            % Controls thrust application, power consumption, and data generation.
        
            % Reset fuel consumed this firing
            obj.fuel_consumed_per_firing = 0;

            % Check if the thruster is healthy
            if obj.health == 0
                obj.commanded_thrust = 0; % Thruster is offline, no thrust can be applied
                obj.command_executed = false; % Mark as not executed
                obj.instantaneous_power_consumption = 0;
                obj.instantaneous_power_consumed = 0;
                return;
            end
        
            % Fire the thruster if the actuation flag is true 
            % (should be set in the function optimize_thruster_dart in sw attitude control)
            if obj.command_actuation 
                % Check warm-up time
                if obj.accumulated_warm_up_time < obj.thruster_warm_up_time
                    % Thruster warming up
                    obj.instantaneous_power_consumption = obj.thruster_warm_up_power_consumed;
                    obj.instantaneous_power_consumed = obj.thruster_warm_up_power_consumed;
                    obj.accumulated_warm_up_time = obj.accumulated_warm_up_time + mission.time_step;
                    obj.command_executed = false; % Not yet ready to fire
                else
                    % Thruster ready to fire
                    obj.instantaneous_power_consumption = obj.command_actuation_power_consumed;
                    obj.instantaneous_power_consumed = obj.command_actuation_power_consumed;

                    % Randomize noise
                    current_thruster_noise = obj.thruster_noise * (2*rand() - 1); % Generates a number between 1.0e-04 and - 1.0e-04

                    % Compute the true thrust with noise
                    obj.true_commanded_thrust = obj.commanded_thrust + current_thruster_noise;

                    % Compute force vector
                    force_vector = obj.orientation * obj.true_commanded_thrust;

                    % Compute the torque generated by the thruster
                    obj.control_torque_MT = cross(obj.location -  mission.true_SC{1, 1}.true_SC_body.location_COM, force_vector);
        
                    % Apply the generated torque to the spacecraft
                    mission.true_SC{i_SC}.true_SC_adc.control_torque = ...
                                mission.true_SC{i_SC}.true_SC_adc.control_torque + obj.control_torque_MT';

                    % Calculate fuel consumption
                    g0 = 9.80665; % m/s^2
                    obj.fuel_consumed_per_firing = (obj.true_commanded_thrust * mission.true_time.time_step_attitude) / (obj.isp * g0);
                    obj.total_fuel_consumed = obj.total_fuel_consumed + obj.fuel_consumed_per_firing;

                    % Consume fuel from the tank if fuel tank exists
                    if isfield(mission.true_SC{i_SC}, 'true_SC_fuel_tank') && ...
                       mission.true_SC{i_SC}.true_SC_body.num_hardware_exists.num_fuel_tank > 0
                        % Find the assigned fuel tank (assuming the first one for now)
                        i_tank = 1;
                        % Consume fuel from the tank
                        mission.true_SC{i_SC}.true_SC_fuel_tank{i_tank}.func_consume_fuel(obj.fuel_consumed_per_firing);
                    end

                    % Generate data for this actuation step
                    obj.instantaneous_data_generated_per_sample = obj.instantaneous_data_volume;
        
                    % Mark as executed
                    obj.command_executed = true;
                end
                                
            else
                % Thruster not actuating
                obj.commanded_thrust = 0;
                obj.true_commanded_thrust = 0;
                obj.control_torque_MT = [0, 0, 0]; % No torque applied
                obj.command_executed = false;
                obj.instantaneous_power_consumption = 0; % No power used
                obj.instantaneous_power_consumed = 0;
                obj.instantaneous_data_generated_per_sample = 0; % No data generated
            end

            % Update Power Consumed
            func_update_instantaneous_power_consumed(mission.true_SC{i_SC}.true_SC_power, obj, mission);

            % Update Data Generated
            func_update_instantaneous_data_generated(mission.true_SC{i_SC}.true_SC_data_handling, obj, mission);

            % Update storage
            func_update_true_SC_micro_thruster_store(obj, mission);
            
            % Add this line to properly reset state after the time step is complete
            % and all data has been stored
            func_reset_state(obj);  % Commented out to avoid multiple resets
        end
    end
end